<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midify - Vocal to MIDI Converter</title>
    <style>
        /* --- ENHANCED MIDIFY DESIGN --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600;700&display=swap');
        
        body {
            font-family: 'Exo 2', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            position: relative;
        }
        
        /* Dynamic Gradient Background */
        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #ff006e);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            z-index: -2;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Overlay for better text readability */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(1px);
            z-index: -1;
        }
        
        .container { 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            position: relative;
            z-index: 1;
        }
        
        /* Header with Recording Controls */
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .header h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            animation: pulse 2s ease-in-out infinite alternate;
            position: relative;
            z-index: 2;
        }
        
        @keyframes pulse {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }
        
        .song-title { 
            font-size: 1.8em; 
            color: #ffffff; 
            margin: 15px 0; 
            min-height: 36px; 
            font-weight: 600;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            letter-spacing: 1px;
            position: relative;
            z-index: 2;
        }
        
        .recording-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            position: relative;
            z-index: 2;
        }
        
        .controls { 
            display: flex; 
            justify-content: center; 
            gap: 25px; 
            margin-top: 10px;
            position: relative;
            z-index: 2;
        }
        
        /* Enhanced Recording Button */
        .record-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        .record-btn.idle {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: white;
        }
        
        .record-btn.recording {
            background: linear-gradient(45deg, #ff4757, #ff6b7a);
            animation: recordPulse 1s infinite;
            box-shadow: 0 0 40px #ff4757;
        }
        
        .record-btn.processing {
            background: linear-gradient(45deg, #ffa502, #ff6348);
            animation: spin 1s linear infinite;
        }
        
        @keyframes recordPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Recording Timer */
        .recording-timer {
            font-family: 'Orbitron', monospace;
            font-size: 1.5em;
            color: #ff4757;
            text-shadow: 0 0 10px #ff4757;
            min-width: 100px;
        }
        
        /* Futuristic Buttons */
        .btn {
            padding: 15px 30px; 
            font-size: 1.1em; 
            border: none;
            border-radius: 50px;
            cursor: pointer; 
            transition: all 0.3s ease; 
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase; 
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:disabled { 
            background: #333 !important; 
            cursor: not-allowed; 
            opacity: 0.5;
            box-shadow: none;
        }
        
        .btn-primary { 
            background: linear-gradient(45deg, #ff006e, #8338ec);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-primary:hover:not(:disabled) { 
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 0, 110, 0.4);
        }
        
        .btn-test {
            background: linear-gradient(45deg, #06ffa5, #2bdfd7);
            color: #000;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-test:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(6, 255, 165, 0.4);
        }
        
        /* Main Karaoke Area */
        .karaoke-area { 
            flex: 1; 
            position: relative; 
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .pitch-display { 
            height: 100%; 
            position: relative;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }
        
        .note-track { 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            z-index: 2; 
        }
        
        /* Enhanced Notes */
        .note {
            position: absolute;
            height: 20px;
            border-radius: 10px;
            color: white;
            transition: all 0.2s ease;
            z-index: 3;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            overflow: hidden;
        }
        
        .note::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.3s;
        }
        
        .note:hover::before {
            left: 100%;
        }
        
        .note.active {
            height: 28px;
            border-radius: 14px;
            box-shadow: 0 0 25px #ffdd00, 0 0 50px #ff8c00, 0 8px 20px rgba(0,0,0,0.4);
            transform: scale(1.2);
            border: 3px solid #fff;
            z-index: 4;
            animation: noteGlow 0.5s ease-in-out;
        }
        
        @keyframes noteGlow {
            0% { box-shadow: 0 0 25px #ffdd00, 0 0 50px #ff8c00; }
            50% { box-shadow: 0 0 35px #ffdd00, 0 0 70px #ff8c00; }
            100% { box-shadow: 0 0 25px #ffdd00, 0 0 50px #ff8c00; }
        }
        
        /* Playback Line for Recorded Audio */
        .playback-line {
            position: absolute; 
            left: 20%; 
            top: 0; 
            bottom: 0; 
            width: 6px;
            background: linear-gradient(to bottom, #ff48c4, #2bdfd7, #ffdd00, #ff48c4);
            background-size: 100% 400%;
            z-index: 5;
            box-shadow: 0 0 20px #2bdfd7, 0 0 40px #ff48c4;
            animation: flow-gradient 3s ease-in-out infinite;
            border-radius: 3px;
            display: none;
        }
        
        .playback-line::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -7px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffffff, #2bdfd7);
            border-radius: 50%;
            box-shadow: 0 0 15px #2bdfd7;
            animation: pulse 1s ease-in-out infinite alternate;
        }
        
        @keyframes flow-gradient {
            0% { background-position: 0% 0%; }
            50% { background-position: 0% 100%; }
            100% { background-position: 0% 0%; }
        }
        
        /* UI Panels */
        .ui-panel { 
            position: absolute; 
            background: rgba(0, 0, 0, 0.8); 
            padding: 12px 20px; 
            border-radius: 15px; 
            backdrop-filter: blur(15px); 
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            font-family: 'Orbitron', monospace;
        }
        
        .progress-info { 
            top: 20px; 
            left: 20px; 
            font-size: 1.2em;
            color: #06ffa5;
            text-shadow: 0 0 10px #06ffa5;
        }
        
        .status { 
            bottom: 20px; 
            right: 20px; 
            color: #3a86ff;
            text-shadow: 0 0 10px #3a86ff;
        }
        
        .model-status {
            top: 20px;
            right: 20px;
            color: #ff006e;
            font-size: 1em;
            text-shadow: 0 0 10px #ff006e;
        }
        
        /* Note Colors - More Vibrant */
        .note-c { background: linear-gradient(45deg, #e74c3c, #c0392b); } 
        .note-cs { background: linear-gradient(45deg, #d35400, #e67e22); } 
        .note-d { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .note-ds { background: linear-gradient(45deg, #f1c40f, #f39c12); } 
        .note-e { background: linear-gradient(45deg, #2ecc71, #27ae60); } 
        .note-f { background: linear-gradient(45deg, #1abc9c, #16a085); }
        .note-fs { background: linear-gradient(45deg, #16a085, #138d75); } 
        .note-g { background: linear-gradient(45deg, #3498db, #2980b9); } 
        .note-gs { background: linear-gradient(45deg, #2980b9, #1f4e79); }
        .note-a { background: linear-gradient(45deg, #9b59b6, #8e44ad); } 
        .note-as { background: linear-gradient(45deg, #8e44ad, #7d3c98); } 
        .note-b { background: linear-gradient(45deg, #c0392b, #a93226); }
        
        /* Starfield Canvas */
        #star-bg { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 0; 
            opacity: 0.7;
        }
        
        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Waveform Visualization */
        .waveform-container {
            width: 300px;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .waveform-bar {
            width: 3px;
            background: #06ffa5;
            margin: 0 1px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .header h1 { font-size: 2.5em; }
            .song-title { font-size: 1.4em; }
            .btn { padding: 12px 24px; font-size: 1em; }
            .controls { gap: 15px; flex-wrap: wrap; }
            .recording-controls { flex-direction: column; gap: 15px; }
            .record-btn { width: 60px; height: 60px; font-size: 2em; }
            .note { height: 16px; font-size: 10px; }
            .note.active { height: 22px; }
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    <div class="overlay"></div>
    
    <div class="container">
        <div class="header">
            <h1>🎤 Midify</h1>
            <div class="song-title" id="songTitle">Record your voice to see MIDI notes!</div>
            
            <div class="recording-controls">
                <button class="record-btn idle" id="recordBtn" onclick="toggleRecording()">
                    🎤
                </button>
                <div class="recording-timer" id="recordingTimer">00:00</div>
                <div class="waveform-container" id="waveformContainer" style="display: none;">
                    <!-- Waveform bars will be added dynamically -->
                </div>
                <div class="volume-control" style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 0.9em; color: #06ffa5;">🔊</span>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1.0" 
                           style="width: 100px; accent-color: #06ffa5;" 
                           onchange="adjustVolume(this.value)">
                    <span id="volumeDisplay" style="font-size: 0.8em; color: #06ffa5; min-width: 30px;">100%</span>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" id="convertBtn" onclick="convertToMidi()" disabled>
                    🎵 Convert to MIDI
                </button>
                <button class="btn btn-primary" id="playBtn" onclick="togglePlayback()" disabled>
                    ▶️ Play
                </button>
                <button class="btn btn-test" onclick="testMode()">
                    🧪 Test Mode
                </button>
            </div>
        </div>
        
        <div class="karaoke-area">
            <canvas id="star-bg"></canvas>
            <div class="pitch-display" id="pitchDisplay">
                <div class="note-track" id="noteTrack"></div>
                <div class="playback-line" id="playbackLine"></div>
            </div>
            <div class="ui-panel progress-info" id="progressInfo">Ready to record</div>
            <div class="ui-panel model-status" id="modelStatus">Checking model...</div>
        </div>
        
        <audio id="audioPlayer" style="display: none;"></audio>
        <div class="ui-panel status" id="status">🎤 Record your voice to convert it to MIDI notes!</div>
    </div>

    <script>
        // --- Global State & Constants ---
        let notes = [];
        let animationFrameId = null;
        let schedulerIntervalId = null;
        let recordedAudioBlob = null;
        let isRecording = false;
        let isPlaying = false;
        let mediaRecorder = null;
        let audioStream = null;
        let recordingStartTime = null;
        let recordingTimer = null;
        let originalAudioData = null;
        let audioDuration = 0;

        const audioPlayer = document.getElementById('audioPlayer');
        const NOTE_LOOKAHEAD_TIME = 0.2;
        const NOTE_SCHEDULE_INTERVAL = 50;
        const noteColors = {
            'C':'note-c', 'C#':'note-cs', 'D':'note-d', 'D#':'note-ds', 'E':'note-e',
            'F':'note-f', 'F#':'note-fs', 'G':'note-g', 'G#':'note-gs', 'A':'note-a',
            'A#':'note-as', 'B':'note-b'
        };

        // --- Web Audio API Setup ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioContext;

        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new AudioContext();
                    console.log("AudioContext created successfully, state:", audioContext.state);
                    
                    // Resume audio context if it's suspended (required by some browsers)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(() => {
                            console.log("AudioContext resumed");
                        });
                    }
                } catch (e) {
                    console.error("Web Audio API error:", e);
                    setStatus("Web Audio API is not supported in this browser.");
                }
            }
            return audioContext && audioContext.state === 'running';
        }

        // --- Initialization ---
        window.addEventListener('load', () => {
            checkModelStatus();
            runStarfield();
        });

        async function checkModelStatus() {
            try {
                const response = await fetch('/api/model_status');
                const status = await response.json();
                
                const statusElement = document.getElementById('modelStatus');
                if (status.model_loaded) {
                    statusElement.textContent = '✅ Model Ready';
                    statusElement.style.color = '#06ffa5';
                } else {
                    statusElement.textContent = '⚠️ Model Not Found';
                    statusElement.style.color = '#ff006e';
                }
            } catch (error) {
                document.getElementById('modelStatus').textContent = '❌ Server Error';
                document.getElementById('modelStatus').style.color = '#ff4757';
            }
        }

        // --- Recording Functions ---
        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                // Request microphone access
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });

                // Create MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                const audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    // Convert to base64 for sending to server
                    const reader = new FileReader();
                    reader.onload = () => {
                        originalAudioData = reader.result;
                        // Enable convert button now that we have audio data
                        document.getElementById('convertBtn').disabled = false;
                        setStatus('✅ Recording complete! Convert to see MIDI notes.');
                    };
                    reader.readAsDataURL(recordedAudioBlob);
                };

                // Start recording
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                updateRecordingUI();
                startRecordingTimer();
                setStatus('🔴 Recording... Speak or sing!');

            } catch (error) {
                console.error('Error starting recording:', error);
                setStatus('❌ Microphone access denied or unavailable');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                audioStream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                updateRecordingUI();
                stopRecordingTimer();
                setStatus('✅ Recording complete! Convert to see MIDI notes.');
            }
        }

        function updateRecordingUI() {
            const recordBtn = document.getElementById('recordBtn');
            const convertBtn = document.getElementById('convertBtn');
            
            if (isRecording) {
                recordBtn.className = 'record-btn recording';
                recordBtn.textContent = '⏹️';
                convertBtn.disabled = true;
            } else {
                recordBtn.className = 'record-btn idle';
                recordBtn.textContent = '🎤';
                // Convert button will be enabled when audio data is ready
                // (handled in the mediaRecorder.onstop callback)
            }
        }

        function startRecordingTimer() {
            recordingTimer = setInterval(() => {
                const elapsed = (Date.now() - recordingStartTime) / 1000;
                const minutes = Math.floor(elapsed / 60);
                const seconds = Math.floor(elapsed % 60);
                document.getElementById('recordingTimer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 100);
        }

        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
        }

        // --- Audio Conversion (Simplified) ---
        // Audio conversion is now handled on the server side for better reliability

        // --- MIDI Conversion ---
        async function convertToMidi() {
            if (!originalAudioData) {
                setStatus('❌ No audio recorded');
                return;
            }

            const convertBtn = document.getElementById('convertBtn');
            convertBtn.disabled = true;
            convertBtn.innerHTML = '<span class="loading"></span> Converting...';
            
            setStatus('🔄 Converting vocals to MIDI...');

            try {
                const response = await fetch('/api/convert_vocal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        audio_data: originalAudioData
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Conversion failed');
                }

                const data = await response.json();
                
                // Store the results
                notes = data.notes;
                audioDuration = data.audio_duration || audioDuration;
                
                // Update UI
                document.getElementById('songTitle').textContent = data.song_name;
                document.getElementById('playBtn').disabled = false;
                
                // Setup audio for playback using URL
                if (data.audio_url) {
                    console.log('Setting audio source to:', data.audio_url);
                    audioPlayer.src = data.audio_url;
                    
                    // Force the audio to load and add event listeners for debugging
                    audioPlayer.load();
                    
                    // Add event listeners for debugging
                    audioPlayer.onloadeddata = () => {
                        console.log('Audio loaded successfully, duration:', audioPlayer.duration);
                        console.log('Audio ready state:', audioPlayer.readyState);
                    };
                    audioPlayer.oncanplay = () => {
                        console.log('Audio can play');
                    };
                    audioPlayer.onerror = (e) => {
                        console.error('Audio loading error:', e);
                        console.error('Audio error code:', audioPlayer.error?.code);
                        console.error('Audio error message:', audioPlayer.error?.message);
                        setStatus('❌ Audio loading failed');
                    };
                    audioPlayer.onloadstart = () => {
                        console.log('Audio load started');
                    };
                }
                
                setStatus(`✅ Conversion complete! Found ${notes.length} notes.`);
                
                // Show the notes immediately
                displayNotes();
                
            } catch (error) {
                console.error('Conversion error:', error);
                setStatus(`❌ Error: ${error.message}`);
            } finally {
                convertBtn.disabled = false;
                convertBtn.innerHTML = '🎵 Convert to MIDI';
            }
        }

        // --- Test Mode ---
        async function testMode() {
            setStatus('🧪 Loading test pattern...');
            
            try {
                const response = await fetch('/api/test_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                notes = data.notes;
                audioDuration = data.audio_duration;
                
                document.getElementById('songTitle').textContent = data.song_name;
                setStatus('✅ Test pattern loaded! Click Play to see animation.');
                
                // Enable playback (will just show animation without audio)
                document.getElementById('playBtn').disabled = false;
                displayNotes();
                
            } catch (error) {
                setStatus(`❌ Test mode failed: ${error.message}`);
            }
        }

        // --- Playback and Animation ---
        function togglePlayback() {
            if (isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (notes.length === 0) {
                setStatus('No MIDI notes to play');
                return;
            }

            isPlaying = true;
            document.getElementById('playBtn').textContent = '⏸️ Pause';
            document.getElementById('playbackLine').style.display = 'block';
            
            // Initialize audio context first
            const audioContextReady = initAudioContext();
            if (!audioContextReady && audioContext) {
                // Try to resume if suspended
                audioContext.resume();
            }
            
            // Start audio if available
            if (audioPlayer.src) {
                console.log('Attempting to play audio from:', audioPlayer.src);
                console.log('Audio ready state:', audioPlayer.readyState);
                audioPlayer.currentTime = 0;
                audioPlayer.play().then(() => {
                    console.log('Audio playback started successfully');
                    
                    // Start note scheduler after a small delay to ensure audio is playing
                    setTimeout(() => {
                        try {
                            if (audioContext && audioContext.state === 'running') {
                                startScheduler();
                                console.log('Note scheduler started after audio');
                            } else {
                                console.log('AudioContext not ready, starting without note sounds');
                            }
                        } catch (e) {
                            console.log('Note scheduler failed:', e);
                        }
                    }, 100); // 100ms delay
                    
                }).catch(e => {
                    console.error('Audio playback failed:', e);
                    setStatus('⚠️ Audio playback failed, showing visual only');
                    // Continue with visual animation even if audio fails
                });
            } else {
                console.log('No audio source available');
                setStatus('⚠️ No audio available, showing visual only');
            }
            
            setStatus('🎵 Playing MIDI visualization...');
            startAnimation();
        }

        function pausePlayback() {
            isPlaying = false;
            document.getElementById('playBtn').textContent = '▶️ Play';
            document.getElementById('playbackLine').style.display = 'none';
            
            if (audioPlayer.src) {
                audioPlayer.pause();
            }
            
            // Stop scheduler and animation
            stopSchedulerAndAnimation();
            
            setStatus('⏸️ Playback paused');
        }

        function stopSchedulerAndAnimation() {
            if (schedulerIntervalId) clearInterval(schedulerIntervalId);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            schedulerIntervalId = null;
            animationFrameId = null;
        }

        // --- Note Scheduler & Player (Web Audio API) ---
        function startScheduler() {
            // Filter out problematic notes (artifacts) - same logic as displayNotes
            const filteredNotes = notes.filter(note => {
                // Remove notes that are too long (likely artifacts)
                if (note.duration > 1.5) return false;
                
                // Remove notes that are extremely short (likely noise)
                if (note.duration < 0.05) return false;
                
                // Remove notes with unreasonable MIDI values
                if (note.midi_note < 20 || note.midi_note > 108) return false;
                
                return true;
            });
            
            const noteQueue = [...filteredNotes].sort((a, b) => a.start_time - b.start_time);
            console.log(`Starting scheduler with ${noteQueue.length} notes (filtered from ${notes.length})`);
            
            schedulerIntervalId = setInterval(() => {
                const currentTime = audioPlayer.currentTime;
                while (noteQueue.length > 0 && noteQueue[0].start_time < currentTime + NOTE_LOOKAHEAD_TIME) {
                    const note = noteQueue.shift();
                    playNoteSound(note, audioContext.currentTime + (note.start_time - currentTime));
                }
            }, NOTE_SCHEDULE_INTERVAL);
        }

        function playNoteSound(note, scheduledTime) {
    if (!audioContext) return;
            
            // Calculate frequency from MIDI note
            const frequency = 440 * Math.pow(2, (note.midi_note - 69) / 12);
            
            // Simple, clean piano-like sound
            const volume = 0.66; // Increased volume for better audibility
            const attackTime = 0.02; // Quick but smooth attack
            const decayTime = Math.min(note.duration * 0.6, 1.5); // Natural decay
            const sustainLevel = 0.3; // Piano sustain level
            const releaseTime = 0.5; // Gentle release
            const stopTime = scheduledTime + note.duration + releaseTime;

            // Create master gain for the note
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);

            // Use only 3 simple harmonics for clean sound
            const harmonics = [
                { ratio: 1.0, amplitude: 1.0 },    // Fundamental frequency
                { ratio: 2.0, amplitude: 0.4 },    // Octave (adds brightness)
                { ratio: 3.0, amplitude: 0.2 }     // Perfect fifth (adds warmth)
            ];

            harmonics.forEach(harmonic => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Use only sine waves for pure, clean tones
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency * harmonic.ratio, scheduledTime);
                
                oscillator.connect(gainNode);
                gainNode.connect(masterGain);
                
                // Clean ADSR envelope
                const harmonicVolume = volume * harmonic.amplitude;
                gainNode.gain.setValueAtTime(0, scheduledTime);
                gainNode.gain.linearRampToValueAtTime(harmonicVolume, scheduledTime + attackTime);
                gainNode.gain.exponentialRampToValueAtTime(harmonicVolume * sustainLevel, scheduledTime + attackTime + decayTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, stopTime);
                
                oscillator.start(scheduledTime);
                oscillator.stop(stopTime);
            });

            // Optional: Add subtle low-pass filter for warmth
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(frequency * 4, scheduledTime); // Gentle filtering
            filter.Q.setValueAtTime(1, scheduledTime);
            
            masterGain.disconnect();
            masterGain.connect(filter);
            filter.connect(audioContext.destination);
        }

        function displayNotes() {
            const noteTrack = document.getElementById('noteTrack');
            noteTrack.innerHTML = '';

            if (notes.length === 0) return;

            // Filter out problematic notes (artifacts)
            const filteredNotes = notes.filter(note => {
                // Remove notes that are too long (likely artifacts)
                if (note.duration > 1.5) {
                    console.log(`Filtering out long note: ${note.note_name} duration=${note.duration.toFixed(2)}s`);
                    return false;
                }
                
                // Remove notes that are extremely short (likely noise)
                if (note.duration < 0.05) {
                    console.log(`Filtering out short note: ${note.note_name} duration=${note.duration.toFixed(3)}s`);
                    return false;
                }
                
                // Remove notes with unreasonable MIDI values
                if (note.midi_note < 20 || note.midi_note > 108) {
                    console.log(`Filtering out extreme MIDI note: ${note.note_name} midi=${note.midi_note}`);
                    return false;
                }
                
                return true;
            });

            console.log(`Filtered ${notes.length - filteredNotes.length} problematic notes, showing ${filteredNotes.length}`);

            // Calculate display parameters
            const displayWidth = window.innerWidth;
            const timeScale = displayWidth / (audioDuration || 5.0);

            const allMidiNotes = filteredNotes.map(n => n.midi_note);
            if (allMidiNotes.length === 0) return;
            
            const minNote = Math.min(...allMidiNotes);
            const maxNote = Math.max(...allMidiNotes);
            
            const padding = 2;
            const displayRange = Math.max(maxNote - minNote + 2 * padding, 24);
            const finalMinNote = minNote - padding;

            // Create note elements
            filteredNotes.forEach((note, index) => {
                const noteElement = document.createElement('div');
                
                const semitoneFromBottom = note.midi_note - finalMinNote;
                const topPercent = 100 - (semitoneFromBottom / displayRange) * 85 - 7.5;
                
                const noteX = note.start_time * timeScale;
                const noteWidth = Math.max(note.duration * timeScale, 30);
                
                noteElement.className = 'note';
                noteElement.style.left = `${noteX}px`;
                noteElement.style.width = `${noteWidth}px`;
                noteElement.style.top = `${topPercent}%`;
                noteElement.textContent = note.note_name;
                
                const noteName = note.note_name.replace(/\d/, '');
                noteElement.classList.add(noteColors[noteName] || 'note-c');
                
                noteTrack.appendChild(noteElement);
            });
        }

        function startAnimation() {
            const startTime = Date.now();
            const playbackLine = document.getElementById('playbackLine');
            const displayWidth = window.innerWidth;
            
            function animate() {
                if (!isPlaying) return;

                const elapsed = (Date.now() - startTime) / 1000;
                const progress = Math.min(elapsed / audioDuration, 1);
                
                // Update playback line position
                const lineX = progress * displayWidth;
                playbackLine.style.left = `${lineX}px`;
                
                // Highlight active notes
                const noteElements = document.querySelectorAll('.note');
                
                // Get filtered notes (same logic as displayNotes)
                const filteredNotes = notes.filter(note => {
                    if (note.duration > 1.5) return false;
                    if (note.duration < 0.05) return false;
                    if (note.midi_note < 20 || note.midi_note > 108) return false;
                    return true;
                });
                
                noteElements.forEach((element, index) => {
                    const note = filteredNotes[index];
                    if (note && elapsed >= note.start_time && elapsed <= note.start_time + note.duration) {
                        element.classList.add('active');
                    } else {
                        element.classList.remove('active');
                    }
                });
                
                // Update progress info
                document.getElementById('progressInfo').textContent = 
                    `${formatTime(elapsed)} / ${formatTime(audioDuration)}`;
                
                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    pausePlayback();
                    setStatus('✅ Playback complete!');
                }
            }
            
            animate();
        }

        // --- Starfield Background ---
        function runStarfield() {
            const canvas = document.getElementById('star-bg');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            let stars = [];
            const starCount = 150;

            for(let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 2,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkle: Math.random() * 0.02 + 0.01
                });
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for(let i = 0; i < stars.length; i++) {
                    const s = stars[i];
                    ctx.globalAlpha = s.opacity;
                    
                    const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius * 3);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, '#88ccff');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.radius * 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }

            function update() {
                for(let i = 0; i < stars.length; i++) {
                    const s = stars[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    
                    s.opacity += s.twinkle;
                    if (s.opacity > 1 || s.opacity < 0.2) {
                        s.twinkle = -s.twinkle;
                    }
                    
                    if(s.x < 0) s.x = canvas.width;
                    if(s.x > canvas.width) s.x = 0;
                    if(s.y < 0) s.y = canvas.height;
                    if(s.y > canvas.height) s.y = 0;
                }
            }

            function animate() {
                draw();
                update();
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // --- Utility Functions ---
        function formatTime(s) { 
            const minutes = Math.floor(s / 60);
            const seconds = Math.floor(s % 60);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function setStatus(msg) { 
            document.getElementById('status').textContent = msg;
        }

        // --- Audio Volume Control ---
        function adjustVolume(value) {
            audioPlayer.volume = parseFloat(value);
            document.getElementById('volumeDisplay').textContent = Math.round(value * 100) + '%';
            console.log('Volume set to:', value);
        }

        // Set initial volume
        audioPlayer.volume = 1.0;

        // --- Event Listeners ---
        audioPlayer.addEventListener('ended', () => {
            pausePlayback();
            setStatus('🎉 Playback finished!');
        });
        
        // Initialize audio context on first user interaction
        document.addEventListener('click', function initAudioOnClick() {
            initAudioContext();
            // Remove this listener after first click
            document.removeEventListener('click', initAudioOnClick);
        }, { once: true });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (notes.length > 0) {
                    togglePlayback();
                }
            } else if (e.code === 'KeyR') {
                e.preventDefault();
                toggleRecording();
            } else if (e.code === 'KeyC') {
                e.preventDefault();
                if (recordedAudioBlob && !document.getElementById('convertBtn').disabled) {
                    convertToMidi();
                }
            }
        });
    </script>
</body>
</html> 